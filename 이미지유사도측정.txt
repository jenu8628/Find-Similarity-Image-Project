3/10
ResNET
 - 이전의 연구들로 모델의 layer가 너무 깊어질수록 오히려 성능이 떨어지는 현상이 생김을 발견
  해당 이슈를 해결하기 위한 노력의 결과

합성곱
- 필터
- 커널
- inner product : 커널을 이용한 내부 연산처리
- stride : 필터를 얼마나 움직일지
- pooling : 각 결과값의 디멘션을 축소해주는 것이 목적
- 제로패딩 : 주변을 0으로 감싸서 크기를 맞춰준다.
- 인풋이미지 -> 합성곱 + 활성화함수 -> 풀링 -> ...
 -> Flatten -> 완전연결계층+분류 -> 활성화함수 + output

엘라스틱서치 검색 사용법 -> SDK 파이썬 엘라스틱서치 사용 방법
es2.danawa.io:9200
FAISS 사용 추천

프로젝트 내용
이미지데이터 -> 모델학습 -> 플라스크
-> 목적: 어떠한 이미지를 입력 이미지에대한 유사이미지를 띄우는페이지

유사 이미지 추천
 - 인셉션 + 파이스 사용
 - 이유: 인셉션을 이용하여 이미지 분류를 진행하고 파이스를 이용하여 이미지 유사도 추천을 할 수 있다.

이미지 추천 모델
1. RNN 이미지 분류 -> 모델 -> 이미지를 모델 예측 -> 카테고리
2. 이미지와 이미지사이의 유사도 측정을 통해서 추천

아래 방식을 채택!
1. 추천에도 카테고리가 적용되어야 함.
2. 코트 이미지 input -> FAISS 만 사용하면 유사한 이미지가 추천됨!
3. 따라서 이미지에 대한 카테고리가 필요하고 카테고리에 해당하는 유사 이미지를 추천!

3/11
이미지 유사도 관련 내용 코드 작성
- 엘라스틱 서치 사용법
- 인셉션 + 파이스 사용
- 내부서버에 올릴 예정

1. 2억개 데이터
2. 700만개만 가져와서
3. 카테고리별로 정리한 다음
4. 카테고리개수 균등하게 남겨서 삭제?

3/14
오늘 쟁점
1. 이미지를 어떻게 할 것인가
1-1) 이미지 파일을 다 저장
 - os.system의 curl을 통해 저장

1-2) pillow 패키지를 통해 이미지사이즈를 통일시킨다
 - pillow의 image모듈의 resize메서드를 통해 이미지 사이즈를 변환

1-3) 저장된 이미지를 array형태로 변환해서 저장한다.
 - np.array를 통해 array형태로 변환

2. 다른방법
2-1) 이미지를 url로 불러오고 resize 메서드를 통해 이미지 사이즈를 변환
2-2) np.array를 통해 array형태로 변환 후 데이터프레임에 저장

error
1. 투명도들어간 이미지 -> img.convert("RGB")로 RGB로 변환
2. 잘린 이미지 -> 삭제
3. 에러 해당 인덱스를 삭제하는 



이미지 사이즈 -> 300 * 300

카테고리 별 100개정도

테스트로 10개 카테고리

의류쪽 카테고리로 진행

카테고리를 한정시켜서 진행

5개 ~ 10개 카테고리에서 300개정도 추출한뒤 늘리는 방법

가방 반바지 코트 청바지 신발 머플러

3/16
1. Faiss 1차원 vs 3차원 비교
- 애초에 차원을 변환함
2. 인셉션으로 분류 추천
3. 플라스크 웹구성 및 서버배포
4. 데이터 추가(이미지 데이터)
5. 유사이미지 추천 관련 기술 블로그 참고하여 추가 개선사항 확인


3/17
 파일 형태 -> 이미지를 저장을 해서 -> resize , np.array 전처리 -> 
기존에 있는 이미지 중 유사 이미지를 추천

이미지를 받을때 -> 해당 이미지 + 모델에 의해 분류된 카테 고리를 통해 증분!

인셉션 -> 
이미지들만 가지고 => 분류될 수 있도록
이미지데이터 제너레이터


3/18
1. 케라스 이미지 제너레이터를 통한 데이터 증강
2. 인셉션 모델학습 진행
3. 예측 과정에서 낮은 적중률의 문제점 발견
4. 문제 해결을 위해 이미지 제너레이터 파라미터 수정 및 모델 파라미터 수정
제일 잘 나온 배치사이즈 -> 32
shuffle=True도 없애보자
inception_best_model_2가 현재 가장 잘나온 모델일듯
배치 사이즈 10은 너무 안됨
배치사이즈 20도 마찬가지여서 25로 진행해봄
배치사이즈 30까지 늘려야할듯
steps_per_epoch도 없애보자

3/21
도커파일작성, 야믈파일작성, 서비스 운영플랫폼 사용하여 서버 올리는 작업까지 진행예정

3/22
도커파일 야믈파일 작성 후 서비스 운영 플랫폼 사용하여 테스트 서버 올리기
FAISS 유사이미지 잘 안되는 이유 - 개선

- docker-compose와 DockerFile을 이용한 docker push 후 테스트 서버 올리는 것까진 가능
2가지 문제

- gitlab-ci.yml의 사용법을 모르겠음

FAISS 문제점 -> 데이터의 개수가 너무 적음

- FAISS의 유사도가 실제로 유사한지를 모르겠음.
- 파라미터 수정
M : 10~12 -> 수정 크게 5개단위 -> 2개단위


깃랩에서 제공하는 지속적인 통합/ 지속적인 배포(CI/CD)를 위한 서비스
CI/CD를 위해서는 쿠버네티스가 필요
깃랩CI/CD

dcr.danawa.io/alpine-k8s-java:8

stages:
- build
- test
- deploy


build
- java -> .class 만들고 jar로 묶어서 실행 가능하게 패키지화
- c -> object 파일을 만들고 executable 파일을 만듬

deploy
- 운영 서버에 배포
<image>:latest

<image>-dev:latest
<image>:rc      -----> 동작은 가능하지만 버그가 있는 / 테스트용

before_script:
- 빌드 전에 실행해주는 스크립트
- 리눅스 쉘 스크립트 명령어를 대부분 다 사용할 수 있음
- mkdir -> make directory
- cp -> copy
- chmod - > 실행 모드 rwx-> read / write / excute
- chown -> 개인 파일 실행 권한
- chgrp -> 그룹 파일 실행 권한
- cd -> change directory
- echo -> print
- cat -> 파일을 스탠다드 아웃풋으로 보내기
- vi -> 편집기
- tail
- head
- ls -> 폴더 리스트 부여주기
- pwd -> 현재 폴더 위치 보여주기


build-dev : 개발용 빌드 develop
build-prod : 운영용 빌드 production

when : 직접 실행을 할 것인가, 깃랩이 자동으로 하게 할 것인가
- manual로 운영을 하고 있음.
- script:
- export
- echo "" >> Dockerfile 앞에 쓴 내용을 도커파일에 쓰겠다.
- docker build -t ${REGISTRY}/${IMAGE}:latest


FAISS
깃랩

3/23
gitlab ci/cd 사용


3/24
1. 이미지 데이터 추가
2. 리뷰
3. 유닛 테스트, 테스트 커버리지
unit test 강의
coverage 사용법

220개 데이터 추가
gitlab-ci.yml

3/28
ojt 진행내용보고서 작성